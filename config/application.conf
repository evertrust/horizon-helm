# Akka configurations
akka {
  loglevel = "{{ .Values.logback.level }}"
  extensions = ["akka.cluster.pubsub.DistributedPubSub"]
  log-dead-letters = off
  log-dead-letters-during-shutdown = off
  http.parsing.max-uri-length = 64k
  actor {
    provider = cluster
    serialize-messages = on
    serializers {
      proto = "akka.remote.serialization.ProtobufSerializer"
    }
    serialization-bindings {
      "actors.serializer.Serializable" = proto
    }
  }
  remote {
    log-remote-lifecycle-events = off
    transport = tcp
    artery {
      canonical {
        hostname = ${?HOSTNAME}
        port = 25520
      }
      bind {
        hostname = 0.0.0.0
        port = 25520
      }
    }
  }
  management {
    http {
      hostname = ${?HOSTNAME}
      bind-hostname = 0.0.0.0
      port = 8558
      bind-port = 8558
    }
    health-checks {
      readiness-checks {
        horizon = "healthcheck.HorizonHealthCheck"
      }
    }
    cluster.bootstrap {
      contact-point-discovery {
        port-name = management
        protocol = tcp
        service-name = "{{ .Release.Name }}-discovery"
        service-namespace = "{{ .Release.Namespace }}.svc.cluster.local"
        discovery-method = akka-dns
        {{ if .Values.horizontalAutoscaler.enabled }}
        required-contact-point-nr = "{{ .Values.horizontalAutoscaler.minReplicas }}"
        {{ else }}
        required-contact-point-nr = 1
        {{ end }}
      }
    }
  }
  cluster {
    downing-provider-class = "akka.cluster.sbr.SplitBrainResolverProvider"
    shutdown-after-unsuccessful-join-seed-nodes = 60s
    pub-sub {
      name = distributedPubSubMediator
      role = master
      routing-logic = random
      send-to-dead-letters-when-no-subscribers = on
    }
  }
  coordinated-shutdown.exit-jvm = off
}

# Specific dispatcher to isolate the actors with blocking IO
blocking-io-dispatcher {
  executor = "thread-pool-executor"
  throughput = 1
  thread-pool-executor {
    fixed-pool-size = 10
  }
}

# Play configurations
play {
  http.filters = filters.horizon.HorizonFilters
  http.secret.key = ${?APPLICATION_SECRET}
  filters {
    hosts.allowed = [{{ include "horizon.allowedHosts" . }}]
    enabled += "play.filters.cors.CORSFilter"
    csrf.cookie.name = csrf-token
  }
  i18n.langs = ["en", "en-US"]
  modules {
    enabled += "play.modules.reactivemongo.ReactiveMongoModule"
    enabled += "modules.HorizonModule"
  }
  assets {
    path = "/public"
    urlPrefix = "/assets"
  }
  mailer {
    host = {{ .Values.mailer.host | default "null" }}
    port = {{ .Values.mailer.port }}
    ssl = {{ .Values.mailer.ssl | ternary "yes" "no" }}
    tls = {{ .Values.mailer.tls | ternary "yes" "no" }}
    user = {{ .Values.mailer.user | quote | default "null" }}
    password = ${?MAILER_PASSWORD}
  }
}

# Kamon configurations
kamon {
  modules {
    apm-reporter.enabled = false
    prometheus-reporter.enabled = true
    host-metrics.enabled = false
  }
  prometheus {
    include-environment-tags = true
    embedded-server {
      hostname = 0.0.0.0
      port = 9095
    }
  }
}

# MongoDB configurations
mongodb.uri = ${?MONGODB_URI}

horizon {

  # License file
  license.file = "/horizon/license/horizon.lic"

  # Default Certificate constraints
  default.constraints {
    allowed.domains = "^(\\*\\.)?([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+[a-zA-Z]{2,}$"
    rsa.minimal.key.size = 2048
    ec.allowed.curves = "secp256r1,secp384r1,secp521r1"
  }

  acme.url.scheme = "http"

  # Vault configuration
  vault.configuration = "{{ .Values.vault.configuration }}"
  vault.escrow = "{{ .Values.vault.escrow }}"
  vault.transient = "{{ .Values.vault.transient }}"
  vaults {
    {{- range $name, $params := .Values.vaults }}
      {{ $name | quote }} {
        {{- range $key, $value := $params }}
          {{- if eq $key "master_password" }}
            "master_password" = {{ printf "${?%s_master_password}" $name | upper -}}
          {{- else -}}
            {{ $key | quote }} = {{ $value | quote -}}
          {{- end }}
        {{ end }}
      }
    {{- end }}
  }
}